# HTTP-TIL
-----------------------------------------------------------------------------------------
<h1>IP(Internet Protocol)</h1>
- 지정한 IP주소에 데이터 전달<br>
- 패킷이라는 통신 단위로 데이터 전달<br>
- IP 패킷 정보: 출발지IP, 목적지IP, etc...를 포함한 전송데이터<br>
- 원리: 클라이언트에서 목적지IP(서버)로 전송데이터를 전달하고 패킷에서 출발지IP를 확인한 서버는 다시 그 IP주소로 응답을 보냄<br>

<h2>IP프로토콜의 한계</h2>
- 비연결성: 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송<br>
- 비신뢰성: 중간에 패킷이 사라진다면? / 패킷이 순서대로 안오면?
- 프로그램 구분: 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상이면

--------------------------------------------------------------------
<h1>인터넷 프로토콜의 4계층</h1>
- 애플리케이션 계층(HTTP, FTP)<br>
- 전송 계층(TCP, UDP)<br>
- 인터넷 계층(IP)<br>
- 네트워크 인터페이스 계층


--------------------------------------------------------------------
<h1>TCP(Transmission Control Protocol)</h1>
- IP 패킷 정보: 출발지IP, 목적지IP, etc...를 포함한 전송데이터<br>
- TCP/IP 패킷 정보: 출발지IP, 목적지IP, etc... + 출발지PORT, 목적지PORT, 전송제어, 순서, 검증 정보 etc..를 포함한 전송데이터<br>

<h2>TCP 특징</h2>
- 연결지향 - TCP 3 way handshake (가상 연결)<br>
- 데이터 전달 보증<br>
- 순서 보장<br>
- 신뢰할 수 있는 프로토콜 / 현재는 대부분 TCP사용

<h2>TCP 3 way handshake</h2>
1.클라이언트 -> 서버: SYN<br>
2.서버 -> 클라이언트: SYN + ACK<br>
3.클라이언트 -> 서버: ACK<br>

- SYN: 접속 요청<br>
- ACK: 요청 수락<br>

--------------------------------------------------------------------
<h1>UDP(User Datagram Protocol)</h1>

<h2>UDP 특징</h2>
- 하얀 도화지에 비유(기능이 거의 없음:PORT기능이 끝)
- 연결지향 - TCP 3way handshake X
- 데이터 전달 보증 X
- 순서 보장 X
- 데이터 전달 및 순서가 보장되진 않지만, 단순하고 빠름
- 정리: IP와 거의 같다 + PORT -> 애플리케이션에서 추가 작업 필요

--------------------------------------------------------------------
<h1>PORT</h1>
한 IP로 한번에 둘 이상 연결해야 한다면? -> PORT가 이 문제를 해결<br>
- 0~65535할당 가능<br>
- 0~1023: 잘 알려진 포트, 사용하지 않는 것이 좋음<br>
- FTP:20,21 / TELNET:23 / HTTP:80 / HTTPS:443<br>

<h2>PORT의 역할</h2>
- 같은 IP내에서 프로세스 구분<br>
게임=PORT9080 / 화상통화=PORT21000 / 웹브라우저=PORT10010

--------------------------------------------------------------------
<h1>DNS(Domain Name System)</h1>
IP주소는 기억하기 어렵다 / IP주소는 변경 될 수 있다 -> 이를 해결해 주는 것이 DNS<br>

- 전화번호부에 비유
- 도메인 명을 IP주소로 변환시켜줌

<h2>DNS 원리</h2>
1.클라이언트에서 도메인 명 입력<br>
2.도메인의 실제 IP주소를 반환받음<br>
3.서버로 IP주소 전달해서 응답받음

--------------------------------------------------------------------
<h1>URI(Uniform Resource Identifier)</h1>
URI = URL(Locator) + URN(Name)<br>

<h2>문법</h2>
• scheme://[userinfo@]host[:port][/path][?query][#fragment]<br>
• https://www.google.com:443/search?q=hello&hl=ko<br><br>
• 프로토콜(https)<br>
• 호스트명(www.google.com)<br>
• 포트 번호(443)<br>
• 패스(/search)<br>
• 쿼리 파라미터(q=hello&hl=ko)<br>

--------------------------------------------------------------------
<h1>HTTP의 특징</h1>
- 클라이언트/서버 구조<br>
- 무상태 프로토콜(StateLess), 비연결성<br>
- HTTP 메시지<br>
- 단순함 확장 가능<br>

<hr>

<h2>클라이언트 서버 구조</h2>
- Request / Response 구조<br>
- 클라리언트는 서버에 요청을 보내고, 응답을 대기<br>
- 서버가 요청에 대한 결과를 만들어서 응답<br>

<hr>

<h2>무상태 프로토콜(Stateless)</h2>
- 서버가 클라이언트의 상태를 보존X<br>
- 장점: 서버 확장성 높음(스케일 아웃)<br>
- 단점: 클라리언트가 추가 데이터 전송<br>

<h3>Stateful, Stateless 차이</h3>
상태 유지 - Stateful<br>
• 고객: 이 <strong>노트북</strong> 얼마인가요?<br>
• 점원: 100만원 입니다. <strong>(노트북 상태 유지)</strong><br>
• 고객: 2개 구매하겠습니다.<br>
• 점원: 200만원 입니다. 신용카드, 현금중에 어떤 걸로 구매 하시겠어요?<strong>(노트북, 2개 상태 유지)</strong><br>
• 고객: 신용카드로 구매하겠습니다.<br>
• 점원: 200만원 결제 완료되었습니다. <strong>(노트북, 2개, 신용카드 상태 유지)</strong><br>
<br>
무상태 - Stateless<br>
• 고객: 이 <strong>노트북</strong> 얼마인가요?<br>
• 점원: 100만원 입니다.<br>
• 고객: 노트북 <strong>2개</strong> 구매하겠습니다.<br>
• 점원: 노트북 2개는 200만원 입니다. <strong>신용카드, 현금중</strong>에 어떤 걸로 구매 하시겠어요?<br>
• 고객: <strong>노트북 2개를 신용카드</strong>로 구매하겠습니다.<br>
• 점원: 200만원 결제 완료되었습니다<br>
<br>
- 상태 유지: 중간에 다른 점원으로 바뀌면 안된다.(점원 변경시 상태정보를 다른 점원에게 미리 넘겨줘야 한다.)<br>
=> 항상 같은 서버가 유지되어야 한다<br>
- 무상태: 중간에 다른 점원으로 바뀌어도 된다.<br>
"갑자기 고객이 증가해도 점원을 대거 투입할 수 있다" => 갑자기 클라이언트 요청이 증가해도 서버를 대거 투입할 수 있다.<br>
무상태는 응답 서버를 쉽게 바꿀 수 있다. => <strong>무한한 서버 증설 가능</strong>

<hr>

<h3>Stateless의 실무 한계</h3>
- 모든 것을 무상태로 설계 할 수 있는 경우도 있고 없는 경우도 있다.<br>
- 무상태로 설계 가능 -> 로그인이 필요없는 단순한 서비스 소개 화면<br>
- 상태유지로 설계 해야하는 것 -> 로그인(로그인한 사용자의 경우 로그인 했다는 상태를 서버에 유지)
- 일반적으로 브라우저 쿠키와 서버 세션등을 사용해서 상태유지
- 상태유지는 최소한만 사용

<hr>

<h2>비연결성(connectionless)</h2>
- HTTP는 기본이 연결을 유지하지 않는 모델
- 일반적으로 초 단위의 이하의 빠른 속도로 응답
- 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이
하로 매우 작음
- 예) 웹 브라우저에서 계속 연속해서 검색 버튼을 누르지는 않는다.
- 서버 자원을 매우 효율적으로 사용할 수 있음

<h3>비 연결성의 한계와 극복</h3>
- 한계<br>
1.TCP/IP 연결을 새로 맺어야 함 - 3 way handshake 시간 추가<br>
2.웹 브라우저로 사이트를 요청하면 HTML 뿐만 아니라 자바스크립트, css, 추가 이미지 등 수 많은 자원이 함께 다운로드<br>
- 극복<br>
1.지금은 HTTP 지속 연결(Persistent Connections)로 문제 해결
2.HTTP/2, HTTP/3에서 더 많은 최적화

<hr>

<h2>HTTP 메시지</h2>
모든 것을 HTTP로 전달하는 시대<br>
- HTML, TEXT<br>
- IMAGE, 음성, 영상, 파일<br>
- JSON, XML<br>
- 거의 모든 형태의 데이터 전송 가능<br>
- 서버간에 데이터를 주고 받을 떄도 대부분 HTTP사용<br>

<h3>HTTP 메시지 구조</h3>
- start-line 시작라인<br>
- header 헤더<br>
- empty line 공백라인(CRLF)<br>
- message body<br>
공식 스펙: <br>
HTTP-message = start-line<br>
 *( header-field CRLF )<br>
 CRLF<br>
 [ message-body ] <br>


--------------------------------------------------------------------
<h1></h1>
--------------------------------------------------------------------
<h1></h1>
--------------------------------------------------------------------
<h1></h1>
--------------------------------------------------------------------
<h1></h1>
--------------------------------------------------------------------
<h1></h1>
--------------------------------------------------------------------
<h1></h1>
--------------------------------------------------------------------
<h1></h1>
--------------------------------------------------------------------
<h1></h1>
--------------------------------------------------------------------
<h1></h1>
--------------------------------------------------------------------
<h1></h1>
--------------------------------------------------------------------
<h1></h1>

